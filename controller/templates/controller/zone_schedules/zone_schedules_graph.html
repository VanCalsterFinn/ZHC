{% extends 'controller/base_controller.html' %}
{% load static %}

{% block content_dashboard %}
<div class="container-fluid px-0">
    <h3 class="text-center py-3">{{ zone.name }} - Schedule Graph</h3>
    <div style="width:100%; height:60vh; max-height:600px;">
        <canvas id="zoneScheduleChart"></canvas>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function() {
    const zoneId = {{ zone.id }};
    const ecoTemp = {{ eco_temperature }};
    const dayNames = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'];
    const colors = ['#e74c3c','#3498db','#2ecc71','#f39c12','#9b59b6','#1abc9c','#e67e22'];

    fetch(`/api/zone/${zoneId}/schedule/`)
        .then(res => res.json())
        .then(data => {
            const datasets = [];
            const delta = 0.5 / 1; // 30 min offset

            dayNames.forEach((day, index) => {
                const scheds = data.schedule[day] || [];
                const x = [];
                const y = [];
                currentHour = 0;
                const delta = 0.5; // 30 minutes

                scheds.forEach((s, i) => {
                    const [sh, sm] = s.start_time.split(":").map(Number);
                    const [eh, em] = s.end_time.split(":").map(Number);
                    const startHour = sh + sm/60;
                    const endHour = eh + em/60;

                    if(currentHour < startHour){
                        // Only apply delta if it's not the very first block
                        const ecoStart = (i === 0) ? 0 : currentHour + delta;
                        const ecoEnd = startHour - delta;
                        x.push(ecoStart, ecoEnd);
                        y.push(ecoTemp, ecoTemp);
                    }

                    // Schedule block
                    x.push(startHour, endHour);
                    y.push(s.target_temperature, s.target_temperature);

                    currentHour = endHour;
                });

                // After last block, fill to end of day
                if(currentHour < 24){
                    const ecoStart = currentHour + (scheds.length ? delta : 0);
                    x.push(ecoStart, 24);
                    y.push(ecoTemp, ecoTemp);
                }


                datasets.push({
                    label: day,
                    data: x.map((t,i)=>({x:t, y:y[i]})),
                    borderColor: colors[index],
                    backgroundColor: colors[index]+'33', // semi-transparent fill
                    tension: 0.3,
                    pointRadius: 2,
                    pointHoverRadius: 4,
                    borderWidth: 2
                });
            });

            new Chart(document.getElementById('zoneScheduleChart'), {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'nearest', intersect: false },
                    plugins: {
                        legend: { position: 'top', labels: { usePointStyle: true, font: { size: 12 } } },
                        tooltip: {
                            callbacks: {
                                title: function(tooltipItems){
                                    const hDec = tooltipItems[0].parsed.x;
                                    const h = Math.floor(hDec);
                                    const m = Math.round((hDec - h) * 60);
                                    return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
                                },
                                label: function(context){
                                    const hDec = context.parsed.x;
                                    const h = Math.floor(hDec);
                                    const m = Math.round((hDec - h) * 60);
                                    return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')} - ${context.parsed.y}°C`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            min: 0,
                            max: 24,
                            title: { display: true, text: 'Hour of Day' },
                            ticks: {
                                stepSize: 1,
                                callback: v => {
                                    const h = Math.floor(v);
                                    const m = Math.round((v - h)*60);
                                    return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
                                }
                            },
                            grid: { color: '#f0f0f0' }
                        },
                        y: {
                            min: 0,
                            max: 30,
                            title: { display: true, text: 'Target Temperature (°C)' },
                            grid: { color: '#f0f0f0' }
                        }
                    }
                }
            });
        });
});
</script>
{% endblock %}
